import { isBooleanLike, isNumberLike, isSimpleContainerToken, isSimpleScalarToken, simpleScalarToken, stripAfter, stripBefore, stripSurround } from "src/runtime/index";
import { Never } from "src/constants/Never";
// TODO
export const asSimpleToken = (_val) => {
    return "not ready";
};
const scalarToToken = {
    string: "<<string>>",
    number: "<<number>>",
    boolean: "<<boolean>>",
    true: "<<true>>",
    false: "<<false>>",
    null: "<<null>>",
    undefined: "<<undefined>>",
    unknown: "<<unknown>>",
    any: "<<any>>",
    never: "<<never>>",
};
const _containerToToken = {
    "array(string)": "",
    "array(boolean)": "",
    "array(number)": "",
    "array(unknown)": "",
};
// const unionToToken : Record<string, unknown> = {
//   "Opt<string>": "<<union::[ <<string>>, <<undefined>> ]>>" as unknown ,
//   "Opt<number>": "<<union::[ <<number>>, <<undefined>> ]>>" as unknown,
//   "Opt<unknown>": "<<union::[ <<unknown>>, <<undefined>> ]>>" as unknown,
//   "Opt<boolean>": "<<union::[ <<boolean>>, <<undefined>> ]>>" as unknown,
// } satisfies Record<SimpleUnionToken, unknown>
const stringLiteral = (str) => {
    return stripAfter(stripBefore(str, "string("), ")");
};
const numericLiteral = (str) => {
    return stripAfter(stripBefore(str, "number("), ")");
};
/**
 * **simpleScalarTokenToTypeToken**`(val)`
 *
 * Receives a `SimpleScalarToken` and converts it's runtime value to a
 * more full fledged `TypeToken` while converting the _type_ to be the
 * type that the token represents.
 *
 * **Related:** `simplContainerTokenToTypeToken`, `asTypeToken`
 */
export const simpleScalarTokenToTypeToken = (val) => {
    return (val in scalarToToken
        ? scalarToToken[val]
        : val.startsWith("string(")
            ? stringLiteral(val).includes(",")
                ? `<<union::[ ${stringLiteral(val).split(/,\s{0,1}/).map(i => `"${i}"`).join(", ")} ]>>`
                : `<<string::${stringLiteral(val)}>>`
            : val.startsWith("number(")
                ? numericLiteral(val).includes(",")
                    ? `<<union::[ ${numericLiteral(val).split(/,\s{0,1}/).join(", ")} ]>>`
                    : `<<number::${numericLiteral(val)}>>`
                : `<<never>>`);
};
/**
 * converts a node in the union to a proper token or tokens
 */
const unionNode = (node) => {
    return isNumberLike(node)
        ? `<<number::${node}>>`
        : isBooleanLike(node)
            ? `<<${node}>>`
            : isSimpleContainerToken(node)
                ? simpleContainerTokenToTypeToken(node)
                : isSimpleScalarToken(node)
                    ? simpleScalarToken(node)
                    : `<<string::${node}>>`;
};
const union = (nodes) => {
    return Array.isArray(nodes)
        ? nodes.map(n => unionNode(n))
        : nodes.includes(",")
            ? nodes.split(/,\s{0,1}/).map(n => unionNode(n)).join(", ")
            : unionNode(nodes);
};
const stripUnion = stripSurround("Union(", ")");
/**
 * **simpleUnionTokenToTypeToken**`(val)`
 *
 * Converts a `SimpleUnionToken` to a `TypeToken` and converts the type to
 * the type _represented_ by the token.
 *
 * Note:
 * - when passing in _literals_ such as `opt(42)` it will evaluate the value
 * as being a numeric or a boolean literal and use that type if it is
 */
export const simpleUnionTokenToTypeToken = (val) => {
    return (val.startsWith(`Union(`) && val.endsWith(`)`)
        ? `<<union::[ ${union(stripUnion(val))} ]>>`
        : Never);
};
/**
 * **simpleContainerTokenToTypeToken**`(val)`
 *
 * Receives a `SimpleContainerToken` and converts it's runtime value to a
 * more full fledged `TypeToken` while converting the _type_ to be the
 * type that the token represents.
 *
 * **Related:** `simpleScalarTokenToTypeToken`, `asTypeToken`
 */
export const simpleContainerTokenToTypeToken = (_val) => {
    // TODO
};
// TODO
export const asTypeToken = (_val) => {
    return "not ready";
};
