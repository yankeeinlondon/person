import type { Narrowable, Box, AnyObject } from "src/types/index";
export type BoxValue<T extends Box<unknown>> = T extends Box<infer V> ? V : never;
export type BoxedFnParams<T extends Box<unknown>> = T extends Box<infer V> ? V extends (...args: infer A) => unknown ? A : [] : [];
/**
 * Allows a value with an inner-type to be boxed into a dictionary
 * so that this type inference is preserved with the help of
 * [instantiation expressions](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#instantiation-expressions).
 *
 * NOTE: this feature is immature at best right now
 */
export declare function box<T extends Narrowable>(value: T): Box<T>;
export declare function isBox(thing: Narrowable): thing is Box<unknown>;
/**
 * **boxDictionaryValues**(dict)
 *
 * Runtime utility which boxes each value in a dictionary
 */
export declare function boxDictionaryValues<T extends AnyObject>(dict: T): { [K in keyof T]: Box<T[K]>; };
export type Unbox<T> = T extends Box<infer U> ? U : T;
/**
 * **unbox**(maybeBox)
 *
 * Unboxes a value if it was a box; otherwise it leaves _as is_.
 */
export declare function unbox<T extends Narrowable>(val: T): Unbox<T>;
//# sourceMappingURL=box.d.ts.map