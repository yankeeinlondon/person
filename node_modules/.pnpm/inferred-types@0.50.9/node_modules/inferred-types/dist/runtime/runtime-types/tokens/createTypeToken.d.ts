import { If, IsLength, Join, SimpleType, TypeTokenAtomics, TypeTokenKind, TypeTokenSingletons } from "src/types/index";
type BaseReturn<TBase extends TypeTokenKind> = TBase extends TypeTokenAtomics ? `<<${TBase}>>` : TBase extends TypeTokenSingletons ? SingletonClosure<TBase> : unknown;
export type UnionClosure = <T extends readonly unknown[]>(...elements: T) => `union::[${Join<T, ", ">}]`;
/**
 * **SingletonClosure**
 *
 * Closes out the `string` or `number` base types to conclude as
 * either a wide type or a string literal. It does allow for multiple
 * literal values and in this case will need to add a union token as
 * a parameter
 *
 * ```ts
 * // <<string>>
 * const a = closure<"string">();
 * // <<string::foo>>
 * const b = closure<"string">("foo");
 * // <<string::${UnionClosure("foo", "bar")}>>
 * const c = closure<"string">("foo","bar");
 * ```
 */
export type SingletonClosure<T extends "string" | "number"> = <TLit extends readonly SimpleType<T>[]>(...literals: TLit) => If<IsLength<TLit, 0>, `<<${T}>>`, If<IsLength<TLit, 1>, `<<${T}::${TLit[0]}>>`, `<<${T}::>>`>>;
/**
 * **createTypeToken**`(base) => (secondary) => ...`
 *
 * A higher order function designed to creating a valid
 * `TypeToken` simple through a compound process.
 */
export declare const createTypeToken: <TBase extends TypeTokenAtomics>(base: TBase) => BaseReturn<TBase>;
export {};
//# sourceMappingURL=createTypeToken.d.ts.map