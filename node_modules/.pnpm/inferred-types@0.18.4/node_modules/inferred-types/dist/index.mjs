var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/Mutation/MutationFunction.ts
function createMutationFunction(state) {
  return (mutationIdentity) => {
    return mutationIdentity(state);
  };
}

// src/Mutation/MutationIdentity.ts
function MutationIdentity() {
  return function(m) {
    return m;
  };
}

// src/shared/randomString.ts
function randomString() {
  return Math.trunc((1 + Math.random()) * 65536).toString(16).slice(1);
}

// src/shared/uuid.ts
function uuid() {
  return `${randomString()}${randomString()}-${randomString()}-${randomString()}-${randomString()}-${randomString()}-${randomString()}${randomString()}${randomString()}`;
}

// src/shared/valueTypes.ts
var valueTypes = {
  string: ["", false],
  boolean: [true, false],
  number: [0, false],
  function: [() => "", false],
  object: [{}, false],
  array: (arr = []) => [arr, false],
  null: [null, false],
  symbol: [Symbol("type"), false],
  undefined: [void 0, false],
  true: [true, true],
  false: [false, true],
  literal: (v) => {
    return [v, true];
  },
  literalArray: (arr) => [arr, true]
};

// src/utility/keys.ts
function keys(obj, ...without) {
  const v = without.length > 0 ? Object.keys(obj).filter((k) => !without.includes(k)) : Object.keys(obj);
  return v;
}

// src/utility/createFnWithProps.ts
function createFnWithProps(fn, props) {
  return (() => {
    let combined = fn;
    for (const prop of keys(props)) {
      combined[prop] = props[prop];
    }
    return combined;
  })();
}

// src/utility/ruleset.ts
function ruleSet(defn) {
  return defn;
}

// src/utility/api/api.ts
var api = (priv) => (pub) => {
  const surface = () => pub;
  surface.prototype.priv = () => priv;
  return surface;
};

// src/utility/dictionary/arrayToKeyLookup.ts
function arrayToKeyLookup(...keys2) {
  const obj = {};
  for (const key of keys2) {
    obj[key] = true;
  }
  return obj;
}

// src/utility/dictionary/dictionaryTransform.ts
function dictionaryTransform(input, transform) {
  return keys(input).reduce((acc, i) => {
    const key = i;
    return __spreadProps(__spreadValues({}, acc), { [key]: transform(input, key) });
  }, {});
}

// src/utility/dictionary/entries.ts
function entries(obj) {
  const iterable = {
    *[Symbol.iterator]() {
      for (const k of keys(obj)) {
        yield [k, obj[k]];
      }
    }
  };
  return iterable;
}

// src/utility/dictionary/mapValues.ts
function mapValues(obj, valueMapper) {
  return Object.fromEntries([...entries(obj)].map(([k, v]) => [k, valueMapper(v)]));
}

// src/utility/dictionary/strArrayToDict.ts
function strArrayToDict(...strings) {
  return strings.reduce((acc, str) => {
    acc = __spreadProps(__spreadValues({}, acc), { [str]: true });
    return acc;
  }, {});
}

// src/utility/dictionary/valuesOfProp.ts
function valuesOfProp() {
}

// src/utility/dictionary/kv/dictToKv.ts
function dictToKv(obj, _makeTuple = false) {
  return keys(obj).map((k) => {
    return { key: k, value: obj[k] };
  });
}

// src/utility/state/Configurator.ts
function omit(obj, ...removals) {
  const untyped = removals;
  return Object.fromEntries(Object.entries(obj).filter(([key]) => !untyped.includes(key)));
}
function Configurator() {
  let configuration = () => ({});
  const api2 = () => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const config = configuration();
        const updated = __spreadValues(__spreadValues({}, config), keyValue);
        configuration = () => updated;
        return updated;
      },
      remove(key) {
        const config = configuration();
        const updated = omit(config, key);
        configuration = () => updated;
        return updated;
      },
      done() {
        return configuration();
      }
    };
  };
  return api2();
}

// src/utility/state/FluentConfigurator.ts
function FluentConfigurator(initial = {}) {
  const api2 = (current) => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const updated = __spreadValues(__spreadValues({}, keyValue), current);
        return api2(updated);
      },
      done() {
        return current;
      }
    };
  };
  if (initial && typeof initial !== "object") {
    throw new Error("The FluentConfigurator was passed a non-object based value as the initial value. This is not allowed.");
  }
  return initial ? api2(initial) : api2({});
}

// src/utility/state/KeyStorage.ts
function KeyStorage() {
  const api2 = (state) => ({
    add: (...store) => {
      return api2([...state, ...store]);
    },
    remove: (key) => api2(state.filter((i) => i !== key)),
    done: () => state
  });
  return api2([]);
}

// src/utility/dictionary/kv/filterDictArray.ts
function filterDictArray(dictArr, cb) {
  const state = Configurator();
  const updated = dictArr.filter((i) => {
    const [k, v] = i;
    const keep = cb(k, v);
    if (!keep) {
      state.set(k, true);
    }
    return keep;
  });
  return updated;
}

// src/utility/dictionary/kv/kv.ts
function kv(key, value) {
  return { [key]: value };
}

// src/utility/dictionary/kv/kvToDict.ts
function kvToDict(kvArr) {
  const out = {};
  for (const kv2 of kvArr) {
    out[kv2.key] = kv2.value;
  }
  return out;
}

// src/utility/lists/groupBy.ts
function groupBy(_data) {
  throw new Error("not implemented");
  return (_groupBy) => {
  };
}

// src/utility/literals/ExplicitFunction.ts
function ExplicitFunction(fn) {
  return fn;
}

// src/utility/literals/arrayToObject.ts
function arrayToObject(prop, unique) {
  const transform = (arr) => {
    const result = unique !== false ? arr.reduce((acc, v) => __spreadProps(__spreadValues({}, acc), { [v[prop]]: v }), {}) : arr.reduce((acc, v) => {
      const existing = acc[v[prop]] || [];
      return __spreadProps(__spreadValues({}, acc), { [v[prop]]: [...existing, v] });
    }, {});
    return result;
  };
  return transform;
}

// src/utility/literals/defineType.ts
function defineType(literal2 = {}) {
  return (wide = {}) => {
    return literal2 ? __spreadValues(__spreadValues({}, wide), literal2) : wide;
  };
}

// src/utility/literals/identity.ts
var identity = (v) => v;

// src/utility/literals/literal.ts
function idLiteral(o) {
  return __spreadProps(__spreadValues({}, o), { id: o.id });
}
function nameLiteral(o) {
  return o;
}
function kindLiteral(o) {
  return o;
}
function idTypeGuard(_o) {
  return true;
}
function literal(obj) {
  return obj;
}

// src/utility/map-reduce/filter.ts
var equals = (field, val) => ({
  kind: "Equals",
  field,
  val
});
var greater = (field, val) => ({
  kind: "Greater",
  field,
  val
});
var less = (field, val) => ({
  kind: "Less",
  field,
  val
});
var and = (a, b) => ({
  kind: "And",
  a,
  b
});
var or = (a, b) => ({
  kind: "Or",
  a,
  b
});

// src/utility/modelling/Model.ts
function Model(name) {
  return {
    required(_prop) {
      return Model(name);
    },
    optional(_prop) {
      return Model(name);
    },
    done() {
      return {
        __model__: name,
        __kind__: "model"
      };
    }
  };
}

// src/utility/runtime/condition.ts
var condition = (c, input) => {
  return c(input);
};

// src/utility/runtime/ifTypeOf.ts
function runtimeExtendsCheck(val, base, narrow = false) {
  if (typeof val !== typeof base) {
    return false;
  }
  switch (typeof val) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "bigint":
      return narrow ? val === base : true;
    case "undefined":
      return true;
    case "function":
      if (narrow) {
        throw new Error(`Use of narrowlyExtends with a function is not possible!`);
      }
      return true;
    case "object":
      if (val === null && base === null) {
        return true;
      }
      return keys(base).every((i) => runtimeExtendsCheck(val[i], base[i], narrow));
  }
}
var ifTypeOf = (val) => ({
  extends: (base) => {
    const valid = runtimeExtendsCheck(val, base, false);
    const trueFalse = valid ? true : false;
    return {
      then: (then) => ({
        else: (elseVal) => {
          return valid ? typeof then === "undefined" ? val : then : elseVal;
        }
      }),
      else: (elseVal) => valid ? val : elseVal
    } && trueFalse;
  },
  narrowlyExtends: (base) => {
    const valid = runtimeExtendsCheck(val, base, true);
    const trueFalse = valid ? true : false;
    return {
      then: (then) => ({
        else: (elseVal) => {
          return valid ? typeof then === "undefined" ? val : then : elseVal;
        }
      }),
      else: (elseVal) => valid ? val : elseVal
    } && trueFalse;
  }
});

// src/utility/runtime/conditions/isArray.ts
function isArray(i) {
  return Array.isArray(i) === true;
}

// src/utility/runtime/conditions/isBoolean.ts
function isBoolean(i) {
  return typeof i === "boolean";
}

// src/utility/runtime/conditions/isFalse.ts
function isFalse(i) {
  return typeof i === "boolean" && !i;
}

// src/utility/runtime/conditions/isFunction.ts
function isFunction(input) {
  return typeof input === "function";
}

// src/utility/runtime/conditions/isLiteral.ts
function isLiteral(...allowed) {
  return (i) => {
    return !allowed.every((v) => i !== v);
  };
}

// src/utility/runtime/conditions/isNull.ts
function isNull(i) {
  return i === null;
}

// src/utility/runtime/conditions/isNumber.ts
function isNumber(i) {
  return typeof i === "number";
}

// src/utility/runtime/conditions/isObject.ts
function isObject(i) {
  return typeof i === "object" && i !== null && Array.isArray(i) === false;
}

// src/utility/runtime/conditions/isString.ts
function isString(i) {
  return typeof i === "string";
}

// src/utility/runtime/conditions/isSymbol.ts
function isSymbol(i) {
  return typeof i === "symbol";
}

// src/utility/runtime/conditions/isTrue.ts
function isTrue(i) {
  return typeof i === "boolean" && i;
}

// src/utility/runtime/conditions/isUndefined.ts
function isUndefined(i) {
  return typeof i === "undefined";
}

// src/utility/runtime/type.ts
var typeApi = () => ({
  string: {
    name: "string",
    type: "",
    typeGuard: (v) => isString(v),
    is: isString
  },
  boolean: {
    name: "boolean",
    type: true,
    typeGuard: (v) => isBoolean(v),
    is: isBoolean
  },
  number: {
    name: "number",
    type: 1,
    typeGuard: (v) => isNumber(v),
    is: isNumber
  },
  function: {
    name: "function",
    type: Function,
    typeGuard: (v) => isFunction(v),
    is: isFunction
  },
  null: {
    name: "null",
    type: null,
    typeGuard: (v) => isNull(v),
    is: isNull
  },
  symbol: {
    name: "symbol",
    type: Symbol(),
    typeGuard: (v) => isSymbol(v),
    is: isSymbol
  },
  undefined: {
    name: "undefined",
    type: void 0,
    typeGuard: (v) => isUndefined(v),
    is: isUndefined
  },
  true: {
    name: "true",
    type: true,
    typeGuard: (v) => isTrue(v),
    is: isTrue
  },
  false: {
    name: "false",
    type: false,
    typeGuard: (v) => isFalse(v),
    is: isFalse
  },
  object: {
    name: "object",
    type: {},
    typeGuard: (v) => isObject(v),
    is: isObject
  },
  array: {
    name: "array",
    type: {},
    typeGuard: (v) => isArray(v),
    is: isObject
  }
});
function isType(t) {
  return typeof t === "object" && ["name", "type", "is"].every((i) => Object.keys(t).includes(i));
}
function type(fn) {
  const result = fn(typeApi());
  if (!isType(result)) {
    throw new Error(`When using type(), the callback passed in returned an invalid type! Value returned was: ${result}`);
  }
  return result;
}

// src/utility/runtime/withValue.ts
function withValue(td) {
  return (obj) => {
    const t = type(td);
    return Object.fromEntries([...entries(obj)].filter(([_key, value]) => {
      return t.typeGuard(value);
    }));
  };
}
export {
  Configurator,
  ExplicitFunction,
  FluentConfigurator,
  KeyStorage,
  Model,
  MutationIdentity,
  and,
  api,
  arrayToKeyLookup,
  arrayToObject,
  condition,
  createFnWithProps,
  createMutationFunction,
  defineType,
  dictToKv,
  dictionaryTransform,
  entries,
  equals,
  filterDictArray,
  greater,
  groupBy,
  idLiteral,
  idTypeGuard,
  identity,
  ifTypeOf,
  isArray,
  isBoolean,
  isFalse,
  isFunction,
  isLiteral,
  isNull,
  isNumber,
  isObject,
  isString,
  isSymbol,
  isTrue,
  isType,
  isUndefined,
  keys,
  kindLiteral,
  kv,
  kvToDict,
  less,
  literal,
  mapValues,
  nameLiteral,
  or,
  randomString,
  ruleSet,
  strArrayToDict,
  type,
  typeApi,
  uuid,
  valueTypes,
  valuesOfProp,
  withValue
};
