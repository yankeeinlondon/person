import type { Narrowable, ConverterDefn, Tuple, Nothing, AnyObject, TypedFunction } from "src/types/index";
type CallIfDefined<Handler> = Handler extends TypedFunction ? ReturnType<Handler> : never;
type ConversionResult<TConvert extends Partial<ConverterDefn<any, any, any, any, any, any>>, TInput extends Narrowable | Tuple> = TInput extends string ? CallIfDefined<TConvert["string"]> : TInput extends number ? CallIfDefined<TConvert["number"]> : TInput extends boolean ? CallIfDefined<TConvert["boolean"]> : TInput extends AnyObject ? CallIfDefined<TConvert["object"]> : TInput extends Tuple ? CallIfDefined<TConvert["tuple"]> : TInput extends Nothing ? CallIfDefined<TConvert["nothing"]> : never;
/**
 * **createConverter**(mapper)
 *
 * A runtime utility which allows for the creation of a function which
 * receives multiple wide types (string, number, boolean, object) and then transform it
 * based on the "wide type" but while retaining the potentially narrow values passed in.
 *
 * The number of wide types which the converter will accept is based on how it configured
 * as there are discrete functions which must be passed in for handling: strings, numbers,
 * booleans, and "objects" (aka, Record<string,any>).
 *
 * ```ts
 * // handles strings and numbers
 * const convert = createConverter({
 *    string: s => `the string was ${s}`,
 *    number: n => `the number was ${n}`,
 * });
 * ```
 */
export declare function createConverter<TStr extends Narrowable = never, TNum extends Narrowable = never, TBool extends Narrowable = never, TObj extends Narrowable = never, TTuple extends Narrowable = never, TNothing extends Narrowable = never>(mapper: Partial<ConverterDefn<TStr, TNum, TBool, TObj, TTuple, TNothing>>): <TInput extends Narrowable | Tuple>(input: TInput) => ConversionResult<typeof mapper, TInput>;
export {};
//# sourceMappingURL=createConverter.d.ts.map