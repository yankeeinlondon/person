import { isIndexable, getEach, get } from "src/runtime/index";
import { ifNotNull } from "../boolean-logic/ifNotNull";
function intersectWithOffset(a, b, deref) {
    const aIndexable = a.every(i => isIndexable(i));
    const bIndexable = b.every(i => isIndexable(i));
    if (!aIndexable || !bIndexable) {
        if (!aIndexable) {
            throw new Error(`The "a" array passed into intersect(a,b) was not fully composed of indexable properties: ${a.map(i => typeof i).join(", ")}`);
        }
        else {
            throw new Error(`The "b" array passed into intersect(a,b) was not fully composed of indexable properties: ${b.map(i => typeof i).join(", ")}`);
        }
    }
    const aMatches = getEach(a, deref);
    const bMatches = getEach(b, deref);
    const sharedKeys = ifNotNull(deref, v => [
        a.filter(i => Array.from(bMatches).includes(get(i, v))),
        b.filter(i => Array.from(aMatches).includes(get(i, v)))
    ], () => a.filter(k => b.includes(k)));
    return sharedKeys;
}
function intersectNoOffset(a, b) {
    return a.length < b.length
        ? a.filter((val) => b.includes(val))
        : b.filter((val) => a.includes(val));
}
/**
 * **intersection**(a,b,[deref])
 *
 * A set operation which provides the _intersection_ between
 * between two array's `a` and `b`.
 *
 * - when passing in arrays, you may also pass in a _dereferencing_ property
 * which will be used for arrays of objects (or sub-arrays) so that the comparison
 * is done on the dereferenced value versus the value as a whole.
 */
export const intersection = (a, b, deref = null) => {
    return (deref === null
        ? intersectNoOffset(a, b)
        : intersectWithOffset(a, b, deref));
};
